#[cfg(test)]
#[macro_use]
extern crate quickcheck;


#[cfg(test)]
mod tests {
  pub fn reverse<T: Clone>(xs: &[T]) -> Vec<T> {
    let mut rev = vec!();
    for x in xs.iter() {
        rev.insert(0, x.clone())
    }
    rev
  }

  quickcheck! {
    fn prop(xs: Vec<usize>) -> bool {
      xs == reverse(&reverse(&xs))
    }
  }
}


// A utility function to print an array p[] of size 'n'
pub fn print_array( p: &mut Vec<isize> ) {

  for i in p.iter().filter(|&x| *x != 0) {
    print!("{} ", i);
  }

  print!("\n");
}

pub fn print_all_unique_parts( n: isize ) -> usize {
  let mut tally = 0;
  let mut p = &mut vec![0; n as usize]; // An array to store a partition
  let mut k: isize = 0;  // Index of last element in a partition
  p[k as usize] = n;  // Initialize first partition as number itself

  // This loop first prints current partition, then generates next
  // partition. The loop stops when the current partition has all 1s
  loop {
    // print current partition
    tally += 1;
    // print_array(p);

    // Generate next partition

    // Find the rightmost non-one value in p[]. Also, update the
    // rem_val so that we know how much value can be accommodated
    let mut rem_val: isize = 0;
    while k >= 0 && p[k as usize] == 1 {
      rem_val += p[k as usize];
      k -= 1;
    }

    // if k < 0, all the values are 1 so there are no more partitions
    if k < 0 { return tally }

    // Decrease the p[k] found above and adjust the rem_val
    p[k as usize] -= 1;
    rem_val += 1;


    // If rem_val is more, then the sorted order is violeted.  Divide
    // rem_val in differnt values of size p[k] and copy these values at
    // different positions after p[k]
    while rem_val > p[k as usize] {
      p[k as usize + 1] = p[k as usize];
      rem_val = rem_val - p[k as usize];
      k += 1;
    }

    // Copy rem_val to next position and increment position
    p[k as usize + 1] = rem_val;
    k += 1;
  }
}

fn main() {
  let total_parts = print_all_unique_parts(80);

  println!("\n\n{}\n\n", total_parts);
}

// pub fn partition( mut table: &mut [[usize; 406]; 406], sum: isize, largest_number: isize ) -> usize {

//   for i in 1..(sum + 1) {
//       for j in 1..(largest_number + 1) {
//           if (i - j) < 0 {
//               table[i as usize][j as usize] = table[i as usize][j as usize - 1];
//               continue;
//           }

//           table[i as usize][j as usize] = table[i as usize][j as usize - 1]+table[i as usize - j as usize][j as usize];
//       }
//   }

//   table[sum as usize][largest_number as usize]
// }

// fn main() {
//   let table: &mut [[usize; 406]; 406] = &mut [[0;406]; 406];
//   let sum: isize = 5;
//   let largest_number: isize = 4;

//   for i in 0..sum {
//     table[i as usize][0] = 0;
//   }
//   for i in 1..largest_number + 1 {
//     table[0][i as usize] = 1;
//   }

//   let num_p = partition(table, sum, largest_number);

//   for i in 0..sum {
//     print!("[ ");
//     for j in 0..largest_number {
//       print!(" {} ", table[i as usize][j as usize]);
//     }
//     print!(" ]");
//   }


// }
